''' Выполняет отрисовку графа '''
    def draw(self):
        # Задать масштаб
        scale = 30
        # Построить фигуру для графика
        fig, ax = plt.subplots()
        # Для каждой начальной вершины выполнить:
        for i in range(len(self.al)):
            # Состояние вершины = 0 (исходное)
            state = 0
            # Получить номер вершины и записать в строку
            res = str(i)
            # Для каждой пары в списке смежности текущей (начальной) вершины:
            for edge in self.al[i]:
                # Получить конечную вершину и вес ребра
                d, w = edge.dest, edge.weight
                # Если оба равны -1 (вершина была удалена), то
                if d == -1 and w == -1:
                    # сменить состояние на 2 (удаленная вершина)
                    state = 2
                # Иначе, если -1 равна только конечная вершина,
                elif d == -1 and w != -1:
                    # Сменить состояние на 1 (петля)
                    state = 1
                else:
                    # Иначе вернуться к исходному состоянию
                    state = 0
                # Если начальная вершина совпадает с конечной (петля),
                if i == d:
                    # дописать в строку с ее номером 'п'
                    res += 'п'
                # Иначе, если состояние не 2 и граф ориентированный либо конечная вершина больше начальной,
                elif state != 2 and (self.directed or d > i):
                    # Создать массив точек по X от начальной до конечной вершины с учетом масштаба
                    x = np.linspace(i * scale, d * scale)
                    # Создать массив из пяти точек по X от начальной до конечной вершины с учетом масштаба
                    x0 = np.linspace(i * scale, d * scale, num=5)
                    # Получить расстояние от начальной до конечной вершины
                    diff = np.abs(d - i)
                    # Если начальная и конечная вершины являются смежными, то
                    if diff == 1:
                        # Создать массив по Y, заполненный нулями (горизонтальная линия)
                        y0 = [0, 0, 0, 0, 0]
                    else:
                        # Иначе создать массив по Y с учетом расстояния (кривая линия)
                        y0 = [0, -6 * diff, -8 * diff, -6 * diff, 0]
                    # Выполнить интерполяцию кубическим сплайном по пяти точкам
                    f = interp1d(x0, y0, kind='cubic')
                    # Получить значение функции на x для y
                    y = f(x)
                    # Найти знак между начальной и конечной вершинами
                    s = np.sign(i - d)
                    # Если вершина не удалена и не является петлей, соединить ее с вершинами графа линиями (ребрами)
                    if state == 0:
                        ax.plot(x, s * y, linewidth=1, color='k')
                    # Если граф направленный, то нарисовать на линиях направление
                    if self.directed and state == 0:
                        xd = [x0[2] + 2 * s, x0[2], x0[2] + 2 * s]
                        yd = [y0[2] - 1, y0[2], y0[2] + 1]
                        yd = [y * s for y in yd]
                        ax.plot(xd, yd, linewidth=1, color='k')
                    # Если граф взвешенный, то подписать вес рядом с линиями
                    if self.weighted and state == 0:
                        xd = [x0[2] + 2 * s, x0[2], x0[2] + 2 * s]
                        yd = [y0[2] - 1, y0[2], y0[2] + 1]
                        yd = [y * s for y in yd]
                        ax.text(xd[2] - s * 2, yd[2] + 3 * s, str(w), size=12,
                                ha="center", va="center")
            # Если вершина не была удалена, нарисовать ее на графике и подписать номер
            if state != 2:
                ax.plot([i * scale, i * scale], [0, 0], linewidth=1, color='k')
                ax.text(i * scale, 0, res, size=20, ha="center", va="center",
                        bbox=dict(facecolor='w', boxstyle="circle"))
        # Вывести график на экран
        ax.axis('off')
        ax.set_aspect(1.0)
        fig.show()